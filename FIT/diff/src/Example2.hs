{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}

module Example2 where

import GHC.Generics
import Data.UUID

import Common (Bar, Result(..), Foo)

-- |'Diff'' diffs two instances of any data using its generic
-- representation into a 'Result' at compile time. See:
--
-- http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html
--
-- for detailed information.
class Diff' f where
  diff' :: f p -> f p -> Result

-- |'V1' is a neutral element with respect to coproduct (sum) types.
-- For example:
--
-- @
-- data Sum = A | B
-- @
--
-- is isomorphic to:
--
-- @
-- data Void
--
-- data Sum = A | B | Void
-- @
--
-- Here 'V1' is a generic equivalent to Void-like (there is an
-- infinite number of them) data types.
instance Diff' V1 where
  diff' = undefined -- the only possible inhabitant.

-- | 'U1' is a neutral element with respect to product types.
-- For example:
--
-- @
-- data Product = Product (A, B)
-- @
--
-- is isomorphic to:
--
-- @
-- data Product = Product (A, B, ())
-- @
--
-- Here 'U1' is a generic equivalent to Unit-like (there is an
-- infinite number of them) data types. Our 'Empty' 'Result'
-- constructor is one of them.
instance Diff' U1 where
  diff' _ _ = Empty

-- | ':*:' is a product-type value constructor. For example:
--
-- @
-- type Product = A :*: B :*: C :*: U1
-- @
--
-- is a generic equivalent to the following tuple:
--
-- @
-- type Product = (A, B, C, ())
-- @
--
-- Hint: Can you spot the similarity with List?
--
-- The way this works is it destructures two generic product types
-- using pattern-matching on ':*:' and feeds them into a 'diff''.
-- It's similar to doing recursive computation on List.
instance (Diff' f, Diff' g) => Diff' (f :*: g) where
  diff' (x :*: y) (x' :*: y') = Tuple (diff' x x') (diff' y y')

-- | 'K1' wraps constant (singleton values).
instance (Diff c) => Diff' (K1 i c) where
  diff' (K1 x) (K1 x') = diff x x'

-- | 'M1' contains metadata.
-- Try this in ghci:
--
-- > :t from $ (1, "1234", ())
instance (Diff' f) => Diff' (M1 i t f) where
  diff' (M1 x) (M1 x') = diff' x x'

-- |'Diff' can diff two instances of any non-generic data.
-- Its instance can be autogenerated using 'Diff'' type class.
class Diff a where
  diff :: a -> a -> Result
  default diff :: (Generic a, Diff' (Rep a)) => a -> a -> Result
  diff a a' = diff' (from a) (from a')

instance Diff Double where
  diff = (DiffDouble .) . (-)

instance Diff [Char] where
  diff = (DiffString .) . (==)

instance Diff UUID where
  diff u u' = diff (toString u) (toString u')

instance Diff Bar

instance Diff Foo
